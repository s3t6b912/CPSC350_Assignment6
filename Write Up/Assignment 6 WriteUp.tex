% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Differences Between Five Different Sorting Algorithms}
\author{Sebastian Brumm}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{The Algorithms}

The algorithms that I used in this assignment are bubble sort, insertion sort, selection sort, merge sort, and quick sort. Bubble sort is supposed to be the slowest among them with a run-time of O($n^2$) in every scenario but being very simple to implement. Insertion sort and selection sort have the same run-time of O($n^2$) in the average case but can run better if the collection meets certain criteria. It is the same situation with merge and quick sor, except that in they average case they only have a run-time of O(nlogn).

\subsection{Time differences}

When I ran each of the algorithms, I progressively used more elements until I got to 100,000, at which point I started getting segmentation faults. My computer is very fast so even at that point the longest algorithm only took about 20 seconds, that being bubble sort. Both merge sort and quick sort happened almost instantaneously. I expected about this difference in run-time but I didn't expect my computer to run through all of them so fast.

\subsection{Tradeoffs}

Each algorithm has different tradeoffs, mainly pertaining to their run-time and complexity. Bubble sort is the slowest but least complex while merge sort is the fastest but most complex. Merge sort also uses a lot of memory, which is where I started getting segmentation faults when using a large amount of numbers.

\subsection{Programming Language}

I used C++ for the implementation of these algorithms. This is better than using something like Java or Python because you can dynamically allocate the memory in C++ to have the program run faster and more efficient.

\subsection{Shortcomings Of Analysis}

Since we are just running the algorithms and timing them, we can't be super efficient in terms of time. Using mathematical analysis is way more efficient, even if it is not always as accurate and does not account for all scenarios.

\end{document}
